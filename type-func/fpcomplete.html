<ul>
<li><p>- compile with</p></li>
<li><p>- <code>pandoc -fhaddock+lhs fpcomplete.lhs &gt;! fpcomplete.html</code></p></li>
</ul>
<pre><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE StandaloneDeriving #-}</code></pre>
<h1>Type functions</h1>
<p>With <code>DataKinds</code> language extension, the following defines a data kind named <code>Nat</code> and two type constructor <code>Z :: Nat</code> and <code>S :: Nat -&gt; 'Nat</code></p>
<p>Check with:</p>
<pre><code>    &gt; :set -XDataKinds
    &gt; :k &#39;Z
</code></pre>
<pre><code>data Nat = Z | S Nat</code></pre>
<p>Note that data kinds other than <code class="sourceCode haskell"><span class="fu">*</span></code> cannot have values.</p>
<p>To define type function, we need the <code>TypeFamilies</code> extension. A type family can be regarded as the type signature of a data function. And the type instances is the implementation of the type function.</p>
<pre><code>type family Plus (m :: Nat) (n :: Nat) :: Nat
type instance Plus Z n = n
type instance Plus (S m) n = S (Plus m n)</code></pre>
<p>We want to make the plus function look more naturally, so we can introduce <code>TypeOperators</code> extension for us to define some syntatic sugars.</p>
<p>Then we can define it in this way:</p>
<pre><code>infixl 6 :+</code></pre>
<pre><code>type family (m :: Nat) :+ (n :: Nat) :: Nat
type instance  Z    :+ n = n
type instance (S m) :+ n = S (m :+ n)</code></pre>
<p>We can also define multiplication in similar way, note we need <code>UndecidableInstances</code> lang ext for this type function to type check.</p>
<pre><code>infixl 7 :*
type family (m :: Nat) :* (n :: Nat) :: Nat
type instance  Z    :* n = Z
type instance (S m) :* n = (m :* n) :+ n</code></pre>
<p>GHC can resolve the name <code>Z</code>/<code>S</code> as type constructors instead of value constructors normally, but whenever there's an ambiguity, we can always use <code>'Z</code>/<code>'S</code> to explicitly denote them as type constructors.</p>
<h1>GADTs</h1>
<p>GADTs (Generalized Algebraic Data-Types) enable us to define types function that depends on types with kinds other than <code class="sourceCode haskell"><span class="fu">*</span></code>. To use GADTs, we need to enable it as GHC language extension.</p>
<p>We define our lengthed-vector like this:</p>
<pre><code>data Vec n a where
   Nil   :: Vec Z a
   Cons  :: a -&gt; Vec n a -&gt; Vec (S n) a</code></pre>
<p>Alternatively, we can define the same thing with type level equality and existential qualitification (language ext <code>ExistentialQuantification</code>):</p>
<pre><code>data Vec&#39; n a = (n ~ Z)             =&gt; Nil&#39;
              | forall m. (n ~ S m) =&gt; Cons&#39; a (Vec&#39; m a)</code></pre>
<p>This <strong>forall m</strong> here should actually be read as <strong>there is some m</strong> (thus is an existential quantification).</p>
<p>We now defined Vec data type, and we want it to derive some standard typeclasses. For this purpose, we need to use <code>StandaloneDeriving</code> language extension instead of the <code>deriving</code> clause.</p>
<pre><code>deriving instance Eq a =&gt; Eq (Vec n a)
deriving instance Show a =&gt; Show (Vec n a)</code></pre>
<p>Let's implement some operations on them.</p>
<pre><code>head&#39; :: Vec (S n) a -&gt; a
head&#39; (Cons x xs) = x</code></pre>
<pre><code>tail&#39; :: Vec (S n) a -&gt; Vec n a
tail&#39; (Cons x xs) = xs</code></pre>
<p>How fun!</p>
<pre><code>-- The following code won&#39;t even compile!
-- head&#39; Nil</code></pre>
<p>Let's play with some type level arithmetic. Define the <code class="sourceCode haskell">append</code> function:</p>
<pre><code>append :: Vec n a -&gt; Vec m a -&gt; Vec (n :+ m) a
append Nil         ys = ys
append (Cons x xs) ys = Cons x (append xs ys)</code></pre>
<p>Happily this type checks! This means GHC checked the logic we encoded in the types and concluded this implementation works. (It only checks the length of the resulting vector though, since we didn't put other info in the type, e.g. the order of elements)</p>
<p>We can also implement these functions:</p>
<pre><code>toList :: Vec n a -&gt; [a]
toList Nil         = []
toList (Cons x xs) = x : toList xs</code></pre>
<pre><code>fromList :: [a] -&gt; Vec n a
fromList []     = Nil
fromList (x:xs) = Cons x $ fromList xs</code></pre>
<pre><code>map&#39; :: (a -&gt; b) -&gt; Vec n a -&gt; Vec n b
map&#39; f Nil         = Nil
map&#39; f (Cons x xs) = Cons (f x) $ map&#39; f xs</code></pre>
<pre><code>uncons :: Vec (S n) a -&gt; (a, Vec n a)
uncons (Cons x xs) = (x, xs)</code></pre>
<pre><code>init&#39; :: Vec (S n) a -&gt; Vec n a
init&#39; (Cons x Nil) = Nil
init&#39; (Cons x xs)  = Cons x (init xs)</code></pre>
<pre><code>last&#39; :: Vec (S n) a -&gt; a
last&#39; (Cons x Nil) = x
last&#39; (Cons x xs)  = last&#39; xs</code></pre>
<pre><code>zipWithSame :: (a -&gt; b -&gt; c) -&gt; Vec n a -&gt; Vec n b -&gt; Vec n c
zipWithSame f Nil         Nil         = Nil
zipWithSame f (Cons x xs) (Cons y ys) = Cons (f x y) $ zipWithSame f xs ys</code></pre>
<pre><code>type family Min (m :: Nat) (n :: Nat) :: Nat
type instance Min Z n         = Z
type instance Min m Z         = Z
type instance Min (S m) (S n) = S (Min m n)</code></pre>
<p>Then we can use <code class="sourceCode haskell"><span class="dt">Min</span></code> to implement a more general version of <code class="sourceCode haskell">zipWith</code>:</p>
<pre><code>zipWith&#39; :: (a -&gt; b -&gt; c) -&gt; Vec m a -&gt; Vec n b -&gt; Vec (Min m n) c
zipWith&#39; f Nil         ys          = Nil
zipWith&#39; f xs          Nil         = Nil
zipWith&#39; f (Cons x xs) (Cons y ys) = Cons (f x y) (zipWith&#39; f xs ys)</code></pre>
<p># Singleton patterns</p>
